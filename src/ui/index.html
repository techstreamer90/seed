<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seed - Model Visualization</title>
    <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: #161b22;
            border-bottom: 1px solid #30363d;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        header h1 {
            font-size: 18px;
            font-weight: 600;
            color: #58a6ff;
        }

        .status-bar {
            display: flex;
            gap: 16px;
            font-size: 13px;
            color: #8b949e;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #238636;
        }

        .status-dot.watching {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        #graph-container {
            flex: 1;
            background: #0d1117;
        }

        #detail-panel {
            width: 350px;
            background: #161b22;
            border-left: 1px solid #30363d;
            overflow-y: auto;
            padding: 16px;
        }

        .panel-header {
            font-size: 14px;
            font-weight: 600;
            color: #58a6ff;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid #30363d;
        }

        .node-type {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .node-type.Reality { background: #238636; color: white; }
        .node-type.Aspiration { background: #a371f7; color: white; }
        .node-type.Gap { background: #f85149; color: white; }
        .node-type.Todo { background: #d29922; color: white; }
        .node-type.Concept { background: #58a6ff; color: white; }
        .node-type.Subsystem { background: #3fb950; color: white; }
        .node-type.Module { background: #8b949e; color: white; }
        .node-type.View { background: #bf8700; color: white; }
        .node-type.Action { background: #da3633; color: white; }
        .node-type.Policy { background: #6e7681; color: white; }
        .node-type.Audit { background: #1f6feb; color: white; }

        .node-label {
            font-size: 16px;
            font-weight: 600;
            color: #f0f6fc;
            margin-bottom: 8px;
        }

        .node-description {
            font-size: 13px;
            color: #8b949e;
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .node-meta {
            font-size: 12px;
            color: #6e7681;
        }

        .node-meta dt {
            font-weight: 600;
            color: #8b949e;
            margin-top: 8px;
        }

        .node-meta dd {
            margin-left: 0;
            margin-top: 2px;
            word-break: break-word;
        }

        .edges-section {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid #30363d;
        }

        .edge-item {
            font-size: 12px;
            padding: 4px 0;
            color: #8b949e;
        }

        .edge-type {
            color: #58a6ff;
            font-weight: 500;
        }

        .filters {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 16px;
        }

        .filter-btn {
            padding: 4px 10px;
            font-size: 12px;
            border: 1px solid #30363d;
            background: transparent;
            color: #8b949e;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .filter-btn:hover {
            border-color: #58a6ff;
            color: #58a6ff;
        }

        .filter-btn.active {
            background: #58a6ff;
            border-color: #58a6ff;
            color: white;
        }

        .empty-state {
            color: #6e7681;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }

        .legend {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            padding: 8px 16px;
            background: #161b22;
            border-top: 1px solid #30363d;
            font-size: 11px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
        }

        /* ==================== Claude UI Overlays ==================== */

        /* Message Overlay - top center, dismissible */
        #message-overlay {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: none;
            max-width: 600px;
            min-width: 300px;
        }

        .message-box {
            padding: 16px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
            display: flex;
            align-items: center;
            gap: 12px;
            animation: slideDown 0.3s ease-out;
        }

        @keyframes slideDown {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .message-box.info {
            background: linear-gradient(135deg, #1f6feb 0%, #388bfd 100%);
            border: 1px solid #58a6ff;
            color: white;
        }

        .message-box.success {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            border: 1px solid #3fb950;
            color: white;
        }

        .message-box.warning {
            background: linear-gradient(135deg, #9e6a03 0%, #d29922 100%);
            border: 1px solid #d29922;
            color: white;
        }

        .message-box.error {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
            border: 1px solid #f85149;
            color: white;
        }

        .message-icon {
            font-size: 20px;
            flex-shrink: 0;
        }

        .message-text {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
        }

        .message-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .message-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        /* Status Panel - slide in from right */
        #status-panel {
            position: fixed;
            top: 50px;
            right: 0;
            width: 400px;
            max-width: 90vw;
            height: calc(100vh - 50px);
            background: #161b22;
            border-left: 1px solid #30363d;
            z-index: 900;
            transform: translateX(100%);
            transition: transform 0.3s ease-out;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #status-panel.visible {
            transform: translateX(0);
        }

        .status-panel-header {
            padding: 16px;
            background: #21262d;
            border-bottom: 1px solid #30363d;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .status-panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #58a6ff;
        }

        .status-panel-close {
            background: none;
            border: none;
            color: #8b949e;
            font-size: 20px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .status-panel-close:hover {
            background: #30363d;
            color: #c9d1d9;
        }

        .status-panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* Status Tree Styles */
        .status-tree {
            font-family: monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .tree-node {
            margin: 4px 0;
        }

        .tree-node-content {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .tree-node-content:hover {
            background: #21262d;
        }

        .tree-node-content.selected {
            background: #388bfd22;
            border: 1px solid #388bfd44;
        }

        .tree-children {
            margin-left: 20px;
            border-left: 1px solid #30363d;
            padding-left: 12px;
        }

        .tree-edge-label {
            font-size: 11px;
            color: #6e7681;
            margin: 8px 0 4px 0;
            text-transform: uppercase;
        }

        /* Status indicators */
        .status-icon {
            font-size: 12px;
            width: 16px;
            text-align: center;
        }

        .status-icon.good { color: #3fb950; }
        .status-icon.warning { color: #d29922; }
        .status-icon.bad { color: #f85149; }
        .status-icon.neutral { color: #6e7681; }

        .tree-label {
            color: #c9d1d9;
            flex: 1;
        }

        .tree-type {
            font-size: 11px;
            color: #8b949e;
            padding: 1px 6px;
            background: #21262d;
            border-radius: 10px;
        }

        .tree-status {
            font-size: 11px;
            color: #6e7681;
        }

        /* Node highlight effect */
        .node-highlight {
            animation: highlightPulse 2s ease-out;
        }

        @keyframes highlightPulse {
            0% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(88, 166, 255, 0); }
            100% { box-shadow: 0 0 0 0 rgba(88, 166, 255, 0); }
        }
    </style>
</head>
<body>
    <header>
        <h1>Seed - Model Visualization</h1>
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot watching" id="status-dot"></div>
                <span id="status-text">Watching model...</span>
            </div>
            <span id="node-count">0 nodes</span>
            <span id="last-update">-</span>
        </div>
    </header>

    <main>
        <div id="graph-container"></div>
        <div id="detail-panel">
            <div class="panel-header">Node Details</div>
            <div class="filters" id="type-filters"></div>
            <div id="node-details">
                <div class="empty-state">Click a node to see details</div>
            </div>
        </div>
    </main>

    <div class="legend" id="legend"></div>

    <!-- Claude UI: Message Overlay -->
    <div id="message-overlay">
        <div class="message-box info">
            <span class="message-icon"></span>
            <span class="message-text"></span>
            <button class="message-close" onclick="hideMessage()">&times;</button>
        </div>
    </div>

    <!-- Claude UI: Status Panel -->
    <div id="status-panel">
        <div class="status-panel-header">
            <span class="status-panel-title">Status</span>
            <button class="status-panel-close" onclick="hideStatusPanel()">&times;</button>
        </div>
        <div class="status-panel-content">
            <div class="status-tree" id="status-tree"></div>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            modelPath: '/model/sketch.json',
            uiModelPath: '/model/sketch.json',
            selfPath: '/src/ui/index.html',  // For auto-reload on code changes
            pollInterval: 1000, // 1 second for responsiveness
            physics: {
                stabilization: { iterations: 100 },
                barnesHut: {
                    gravitationalConstant: -2000,
                    springLength: 150,
                    springConstant: 0.04
                }
            }
        };

        // Node type colors
        const TYPE_COLORS = {
            Reality: '#238636',
            Aspiration: '#a371f7',
            Gap: '#f85149',
            Todo: '#d29922',
            Concept: '#58a6ff',
            Subsystem: '#3fb950',
            Module: '#8b949e',
            View: '#bf8700',
            Action: '#da3633',
            Query: '#1f6feb',
            UIState: '#db61a2',
            Policy: '#6e7681',
            Audit: '#1f6feb',
            Check: '#1f6feb',
            Proof: '#3fb950',
            Change: '#f0883e'
        };

        // Edge styling
        const EDGE_COLORS = {
            CONTAINS: '#30363d',
            USES: '#58a6ff',
            EMBODIES: '#a371f7',
            IMPLEMENTS: '#238636',
            NEEDS: '#d29922',
            TARGETS: '#58a6ff',
            DERIVES_FROM: '#a371f7',
            BLOCKS: '#f85149',
            CLOSES: '#3fb950',
            AUDITS: '#1f6feb',
            GOVERNS: '#6e7681',
            ADDRESSES: '#f85149',
            ADVANCES: '#a371f7',
            PRODUCES: '#3fb950',
            HAS_CHECK: '#1f6feb'
        };

        // State
        let model = null;
        let uiState = null;
        let network = null;
        let lastModelHash = null;
        let activeFilters = new Set();
        let allNodeTypes = new Set();

        // Initialize vis.js network
        function initNetwork() {
            const container = document.getElementById('graph-container');
            const data = { nodes: new vis.DataSet([]), edges: new vis.DataSet([]) };

            const options = {
                nodes: {
                    shape: 'box',
                    margin: 10,
                    font: { color: '#c9d1d9', size: 12 },
                    borderWidth: 2,
                    shadow: true
                },
                edges: {
                    arrows: { to: { enabled: true, scaleFactor: 0.5 } },
                    smooth: { type: 'cubicBezier', forceDirection: 'horizontal' },
                    font: { color: '#6e7681', size: 10, strokeWidth: 0 }
                },
                physics: false,  // Disabled: no wobble on updates. Drag nodes to position them.
                interaction: {
                    hover: true,
                    tooltipDelay: 200
                }
            };

            network = new vis.Network(container, data, options);

            network.on('click', (params) => {
                if (params.nodes.length > 0) {
                    selectNode(params.nodes[0]);
                }
            });

            // Press 'S' to save current layout (positions) for Claude to read
            document.addEventListener('keydown', async (e) => {
                if (e.key === 's' || e.key === 'S') {
                    saveLayoutForClaude();
                }
            });

            return data;
        }

        // Load model from file
        async function loadModel(path) {
            try {
                const response = await fetch(path + '?t=' + Date.now());
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error('Failed to load model:', error);
                return null;
            }
        }

        // Simple hash for change detection
        function hashModel(obj) {
            return JSON.stringify(obj).length + '-' + (obj.updated_at || '');
        }

        // Update the graph visualization
        function updateGraph(data) {
            if (!model || !model.nodes) return;

            const visNodes = [];
            const visEdges = [];

            // Collect all node types
            allNodeTypes.clear();
            model.nodes.forEach(node => allNodeTypes.add(node.type));

            // Filter nodes
            const filteredNodes = model.nodes.filter(node => {
                if (activeFilters.size === 0) return true;
                return activeFilters.has(node.type);
            });

            const nodeIds = new Set(filteredNodes.map(n => n.id));

            // Create vis.js nodes
            filteredNodes.forEach(node => {
                const color = TYPE_COLORS[node.type] || '#6e7681';
                const visNode = {
                    id: node.id,
                    label: node.label || node.id,
                    title: node.description || '',
                    color: {
                        background: color,
                        border: color,
                        highlight: { background: color, border: '#ffffff' },
                        hover: { background: color, border: '#58a6ff' }
                    },
                    font: { color: '#ffffff' },
                    _data: node
                };

                // If model specifies position, use it (Claude controls layout)
                if (node.ui && node.ui.x !== undefined && node.ui.y !== undefined) {
                    visNode.x = node.ui.x;
                    visNode.y = node.ui.y;
                    visNode.fixed = true;  // Lock position completely
                    console.log(`[Position] ${node.id} locked at (${node.ui.x}, ${node.ui.y})`);
                }

                visNodes.push(visNode);
            });

            // Create vis.js edges
            if (model.edges) {
                model.edges.forEach((edge, idx) => {
                    if (nodeIds.has(edge.from) && nodeIds.has(edge.to)) {
                        visEdges.push({
                            id: `edge-${idx}`,
                            from: edge.from,
                            to: edge.to,
                            label: edge.type,
                            color: { color: EDGE_COLORS[edge.type] || '#30363d' },
                            _data: edge
                        });
                    }
                });
            }

            // Update the network
            data.nodes.clear();
            data.edges.clear();
            data.nodes.add(visNodes);
            data.edges.add(visEdges);

            // Force positions for nodes that have ui.x/y in model (multiple passes)
            const applyPositions = () => {
                let count = 0;
                filteredNodes.forEach(node => {
                    if (node.ui && node.ui.x !== undefined && node.ui.y !== undefined) {
                        network.moveNode(node.id, node.ui.x, node.ui.y);
                        count++;
                    }
                });
                if (count > 0) console.log(`[Positions] Applied ${count} fixed positions`);
            };
            setTimeout(applyPositions, 100);
            setTimeout(applyPositions, 500);
            setTimeout(applyPositions, 1000);

            // Update UI
            document.getElementById('node-count').textContent = `${visNodes.length} nodes`;
            document.getElementById('last-update').textContent = new Date().toLocaleTimeString();

            // Update type filters
            updateTypeFilters();
            updateLegend();
        }

        // Update type filter buttons
        function updateTypeFilters() {
            const container = document.getElementById('type-filters');
            container.innerHTML = '';

            const sortedTypes = Array.from(allNodeTypes).sort();
            sortedTypes.forEach(type => {
                const btn = document.createElement('button');
                btn.className = 'filter-btn' + (activeFilters.has(type) ? ' active' : '');
                btn.textContent = type;
                btn.onclick = () => toggleFilter(type);
                container.appendChild(btn);
            });
        }

        // Toggle a type filter
        function toggleFilter(type) {
            if (activeFilters.has(type)) {
                activeFilters.delete(type);
            } else {
                activeFilters.add(type);
            }
            updateGraph(network.body.data);
        }

        // Update legend
        function updateLegend() {
            const container = document.getElementById('legend');
            container.innerHTML = '';

            Object.entries(TYPE_COLORS).forEach(([type, color]) => {
                if (allNodeTypes.has(type)) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.innerHTML = `<div class="legend-color" style="background:${color}"></div>${type}`;
                    container.appendChild(item);
                }
            });
        }

        // Select and show node details
        function selectNode(nodeId) {
            const node = model.nodes.find(n => n.id === nodeId);
            if (!node) return;

            // Update UI state in model (conceptually - for now just highlight)
            network.selectNodes([nodeId]);

            // Find edges for this node
            const incomingEdges = model.edges?.filter(e => e.to === nodeId) || [];
            const outgoingEdges = model.edges?.filter(e => e.from === nodeId) || [];

            // Render details
            const details = document.getElementById('node-details');
            details.innerHTML = `
                <span class="node-type ${node.type}">${node.type}</span>
                <div class="node-label">${node.label || node.id}</div>
                <div class="node-description">${node.description || 'No description'}</div>
                <dl class="node-meta">
                    <dt>ID</dt>
                    <dd>${node.id}</dd>
                    ${node.status ? `<dt>Status</dt><dd>${node.status}</dd>` : ''}
                    ${node.priority ? `<dt>Priority</dt><dd>${node.priority}</dd>` : ''}
                    ${node.source?.path ? `<dt>Path</dt><dd>${node.source.path}</dd>` : ''}
                </dl>
                ${(incomingEdges.length > 0 || outgoingEdges.length > 0) ? `
                    <div class="edges-section">
                        <div class="panel-header">Relationships</div>
                        ${incomingEdges.map(e => `
                            <div class="edge-item">
                                <span class="edge-type">${e.type}</span> from ${e.from}
                            </div>
                        `).join('')}
                        ${outgoingEdges.map(e => `
                            <div class="edge-item">
                                <span class="edge-type">${e.type}</span> to ${e.to}
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
            `;
        }

        // Main polling loop
        async function poll(data) {
            const newModel = await loadModel(CONFIG.modelPath);

            if (newModel) {
                const newHash = hashModel(newModel);
                if (newHash !== lastModelHash) {
                    model = newModel;
                    lastModelHash = newHash;
                    updateGraph(data);
                    document.getElementById('status-text').textContent = 'Model updated';
                    setTimeout(() => {
                        document.getElementById('status-text').textContent = 'Watching model...';
                    }, 2000);
                }
            }

            setTimeout(() => poll(data), CONFIG.pollInterval);
        }

        // Save layout for Claude to read
        async function saveLayoutForClaude() {
            if (!network || !model) return;

            const positions = network.getPositions();
            const layout = {
                saved_at: new Date().toISOString(),
                description: "Current screen layout - positions for each node. Claude can read this to understand what user sees.",
                viewport: network.getViewPosition(),
                scale: network.getScale(),
                node_positions: {}
            };

            // Capture positions
            Object.keys(positions).forEach(nodeId => {
                const pos = positions[nodeId];
                layout.node_positions[nodeId] = {
                    x: Math.round(pos.x),
                    y: Math.round(pos.y)
                };
            });

            // Send to server to save as file
            try {
                const response = await fetch('/ui/layout.json', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(layout, null, 2)
                });

                // Also show in console for copy-paste fallback
                console.log('Layout saved. Claude can read /ui/layout.json');
                console.log(JSON.stringify(layout, null, 2));

                // Visual feedback
                document.getElementById('status-text').textContent = 'Layout saved! (Press S)';
                setTimeout(() => {
                    document.getElementById('status-text').textContent = 'Watching model...';
                }, 2000);
            } catch (e) {
                // Fallback: copy to clipboard
                const text = JSON.stringify(layout, null, 2);
                navigator.clipboard.writeText(text).then(() => {
                    document.getElementById('status-text').textContent = 'Layout copied to clipboard!';
                    setTimeout(() => {
                        document.getElementById('status-text').textContent = 'Watching model...';
                    }, 2000);
                });
            }
        }

        // Auto-reload when Claude changes the renderer code
        let lastCodeHash = null;
        async function checkCodeReload() {
            try {
                const response = await fetch(CONFIG.selfPath + '?t=' + Date.now());
                const code = await response.text();
                const hash = code.length + '-' + code.slice(0, 100);

                if (lastCodeHash === null) {
                    lastCodeHash = hash;
                } else if (hash !== lastCodeHash) {
                    console.log('Code changed, reloading...');
                    document.getElementById('status-text').textContent = 'Code updated, reloading...';
                    setTimeout(() => location.reload(), 500);
                    return;
                }
            } catch (e) {
                console.error('Code reload check failed:', e);
            }
            setTimeout(checkCodeReload, 2000);  // Check every 2 seconds
        }

        // ==================== Claude UI Command Processing ====================

        // Track the last processed command timestamp to avoid re-processing
        let lastProcessedCommandTimestamp = null;

        // Process UI commands from the model
        function processUICommands() {
            if (!model || !model.nodes) return;

            // Find the ui-command node
            const cmdNode = model.nodes.find(n => n.id === 'ui-command');
            if (!cmdNode || !cmdNode.command) return;

            const cmd = cmdNode.command;

            // Skip if already processed
            if (cmd.processed || cmd.timestamp === lastProcessedCommandTimestamp) {
                return;
            }

            console.log('[UICommand] Processing:', cmd.type, cmd.params);
            lastProcessedCommandTimestamp = cmd.timestamp;

            // Execute the command
            switch (cmd.type) {
                case 'message':
                    showOverlayMessage(
                        cmd.params.text,
                        cmd.params.duration || 5000,
                        cmd.params.style || 'info'
                    );
                    break;

                case 'focus':
                    focusOnNode(
                        cmd.params.nodeId,
                        cmd.params.zoom || 1.0,
                        cmd.params.highlight !== false
                    );
                    break;

                case 'status':
                    showStatusPanel(
                        cmd.params.rootId || 'reality-seed',
                        cmd.params.depth || 3
                    );
                    break;

                case 'clear':
                    hideMessage();
                    hideStatusPanel();
                    break;

                default:
                    console.warn('[UICommand] Unknown command type:', cmd.type);
            }
        }

        // Show overlay message
        function showOverlayMessage(text, duration = 5000, style = 'info') {
            const overlay = document.getElementById('message-overlay');
            const box = overlay.querySelector('.message-box');
            const icon = overlay.querySelector('.message-icon');
            const textEl = overlay.querySelector('.message-text');

            // Set style
            box.className = 'message-box ' + style;

            // Set icon based on style
            const icons = {
                info: 'i',
                success: '✓',
                warning: '!',
                error: '✗'
            };
            icon.textContent = icons[style] || 'i';

            // Set text
            textEl.textContent = text;

            // Show overlay
            overlay.style.display = 'block';

            // Auto-hide after duration (unless duration is 0)
            if (duration > 0) {
                setTimeout(() => {
                    hideMessage();
                }, duration);
            }
        }

        // Hide message overlay
        function hideMessage() {
            const overlay = document.getElementById('message-overlay');
            overlay.style.display = 'none';
        }

        // Focus on a specific node
        function focusOnNode(nodeId, zoom = 1.0, highlight = true) {
            if (!network || !model) return;

            // Check if node exists
            const node = model.nodes.find(n => n.id === nodeId);
            if (!node) {
                console.warn('[UICommand] Node not found:', nodeId);
                showOverlayMessage(`Node not found: ${nodeId}`, 3000, 'warning');
                return;
            }

            // Get node position
            const positions = network.getPositions([nodeId]);
            const pos = positions[nodeId];

            if (pos) {
                // Focus on the node
                network.focus(nodeId, {
                    scale: zoom,
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });

                // Highlight/select the node
                if (highlight) {
                    network.selectNodes([nodeId]);
                    selectNode(nodeId);

                    // Add pulse animation
                    const nodeElement = document.querySelector(`[data-node-id="${nodeId}"]`);
                    if (nodeElement) {
                        nodeElement.classList.add('node-highlight');
                        setTimeout(() => nodeElement.classList.remove('node-highlight'), 2000);
                    }
                }
            } else {
                console.warn('[UICommand] Node position not found:', nodeId);
            }
        }

        // Show status panel with hierarchical tree
        function showStatusPanel(rootId = 'reality-seed', maxDepth = 3) {
            const panel = document.getElementById('status-panel');
            const tree = document.getElementById('status-tree');
            const title = panel.querySelector('.status-panel-title');

            // Find root node
            const rootNode = model.nodes.find(n => n.id === rootId);
            if (!rootNode) {
                tree.innerHTML = `<div style="color: #f85149;">Node not found: ${rootId}</div>`;
                panel.classList.add('visible');
                return;
            }

            // Update title
            title.textContent = `Status: ${rootNode.label || rootId}`;

            // Build the tree HTML
            tree.innerHTML = buildStatusTreeHTML(rootId, maxDepth, 0);

            // Show panel
            panel.classList.add('visible');

            // Also focus on the root node in the graph
            focusOnNode(rootId, 0.8, false);
        }

        // Hide status panel
        function hideStatusPanel() {
            const panel = document.getElementById('status-panel');
            panel.classList.remove('visible');
        }

        // Build hierarchical status tree HTML
        function buildStatusTreeHTML(nodeId, maxDepth, currentDepth) {
            if (currentDepth >= maxDepth) return '';

            const node = model.nodes.find(n => n.id === nodeId);
            if (!node) return '';

            // Determine status bucket
            const bucket = getNodeBucket(node);
            const icon = {
                good: '✓',
                warning: '!',
                bad: '✗',
                neutral: '•'
            }[bucket] || '•';

            // Build node line
            let html = `
                <div class="tree-node">
                    <div class="tree-node-content" onclick="onStatusTreeNodeClick('${nodeId}')">
                        <span class="status-icon ${bucket}">${icon}</span>
                        <span class="tree-label">${node.label || nodeId}</span>
                        <span class="tree-type">${node.type || 'Unknown'}</span>
                        ${node.status ? `<span class="tree-status">${node.status}</span>` : ''}
                    </div>
            `;

            // Find children via CONTAINS edges and parent field
            const children = getChildNodes(nodeId);

            if (children.length > 0 && currentDepth < maxDepth - 1) {
                html += '<div class="tree-children">';

                // Group by edge type (though CONTAINS is most common)
                html += '<div class="tree-edge-label">contains</div>';

                for (const child of children) {
                    html += buildStatusTreeHTML(child.id, maxDepth, currentDepth + 1);
                }

                html += '</div>';
            }

            html += '</div>';
            return html;
        }

        // Get node status bucket (good/warning/bad/neutral)
        function getNodeBucket(node) {
            const status = (node.status || '').toLowerCase();

            if (['pass', 'ok', 'green', 'active'].includes(status)) return 'good';
            if (['fail', 'error', 'red'].includes(status)) return 'bad';
            if (['warn', 'warning', 'yellow'].includes(status)) return 'warning';

            // Check evidence if present
            const evidence = node.evidence;
            if (evidence && evidence.save_exec) {
                const lastRun = evidence.save_exec.last_run;
                if (lastRun) {
                    if (lastRun.ok === true) return 'good';
                    if (lastRun.ok === false) return 'bad';
                }
            }

            return 'neutral';
        }

        // Get child nodes (via CONTAINS edges or parent field)
        function getChildNodes(parentId) {
            const children = [];
            const childIds = new Set();

            // Check edges
            if (model.edges) {
                for (const edge of model.edges) {
                    if (edge.type === 'CONTAINS' && edge.from === parentId) {
                        if (!childIds.has(edge.to)) {
                            childIds.add(edge.to);
                            const childNode = model.nodes.find(n => n.id === edge.to);
                            if (childNode) {
                                children.push(childNode);
                            }
                        }
                    }
                }
            }

            // Check parent field
            for (const node of model.nodes) {
                if (node.parent === parentId && !childIds.has(node.id)) {
                    childIds.add(node.id);
                    children.push(node);
                }
            }

            // Sort by label
            children.sort((a, b) => (a.label || a.id).localeCompare(b.label || b.id));

            return children;
        }

        // Handle click on status tree node
        function onStatusTreeNodeClick(nodeId) {
            focusOnNode(nodeId, 1.0, true);

            // Mark as selected in tree
            document.querySelectorAll('.tree-node-content').forEach(el => {
                el.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');
        }

        // Initialize
        async function init() {
            const data = initNetwork();

            // Initial load
            model = await loadModel(CONFIG.modelPath);
            if (model) {
                lastModelHash = hashModel(model);
                updateGraph(data);
                processUICommands();  // Check for commands on initial load
            }

            // Start polling for model changes
            pollWithCommands(data);

            // Start polling for code changes (auto-reload)
            checkCodeReload();
        }

        // Enhanced poll that also processes commands
        async function pollWithCommands(data) {
            const newModel = await loadModel(CONFIG.modelPath);

            if (newModel) {
                const newHash = hashModel(newModel);
                if (newHash !== lastModelHash) {
                    model = newModel;
                    lastModelHash = newHash;
                    updateGraph(data);
                    document.getElementById('status-text').textContent = 'Model updated';
                    setTimeout(() => {
                        document.getElementById('status-text').textContent = 'Watching model...';
                    }, 2000);
                }

                // Always check for commands (even if model didn't change, in case we need to re-process)
                processUICommands();
            }

            setTimeout(() => pollWithCommands(data), CONFIG.pollInterval);
        }

        init();
    </script>
</body>
</html>
